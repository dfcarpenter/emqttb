%%--------------------------------------------------------------------
%% Copyright (c) 2022 EMQ Technologies Co., Ltd. All Rights Reserved.
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%--------------------------------------------------------------------
%% A rather fast rolling average metric
%%
%% It's based on an arroy of 2*N_buckets counters:
%%
%% [sum1, sum2, sum3, ..., count1, count2, count3, ...]
%%
%% Every observation increments sumN by `value' and countN by 1.
%% Every TimeWindow / N_buckets the value of N shifts by 1 (wrapping
%% around N_buckets)
-module(emqttb_rolling_average).

%% API:
-export([new/2, new/3, observe/2, value/1]).

-compile([export_all]).

-export_type([key/0]).

%%================================================================================
%% Type declarations
%%================================================================================

-type key() :: term().

%%================================================================================
%% Macros
%%================================================================================

-define(KEY(K), {?MODULE, K}).

%%================================================================================
%% API funcions
%%================================================================================

-spec new(key(), non_neg_integer()) -> ok.
new(Key, TimeWindow) ->
  new(Key, TimeWindow, 3).

%% Create a new rolling average metric with a certain key and time window (in ms)
-spec new(key(), non_neg_integer(), non_neg_integer()) -> ok.
new(Key, TimeWindow, NBuckets) when NBuckets > 1, TimeWindow > 1 ->
  Cnt = counters:new(NBuckets * 2, [write_concurrency]),
  persistent_term:put(?KEY(Key), {Cnt, TimeWindow, NBuckets});
new(_, _, _) ->
  error(badarg).

%% Update value
-spec observe(key(), non_neg_integer()) -> ok.
observe(Key, Value) ->
  {Cnt, TimeWindow, NBuckets} = persistent_term:get(?KEY(Key)),
  Offset = offset(NBuckets, TimeWindow) + 1,
  counters:add(Cnt, Offset, Value),
  counters:add(Cnt, Offset + NBuckets, 1).

%% Get value
-spec value(key()) -> float().
value(Key) ->
  {Cnt, TimeWindow, NBuckets} = persistent_term:get(?KEY(Key)),
  Offset = offset(NBuckets, TimeWindow),
  Seq = seq(Offset, NBuckets),
  Sums = [counters:get(Cnt, I + 1) || I <- Seq],
  Counts = [counters:get(Cnt, I + 1 + NBuckets) || I <- Seq],
  Points = lists:zip(Sums, Counts),
  {Offset, Seq, Points}.

%%================================================================================
%% Internal functions
%%================================================================================

seq(Offset, NBuckets) ->
  lists:reverse([I rem NBuckets || I <- lists:seq(Offset, Offset + NBuckets - 1)]).

offset(NBuckets, TimeWindow) ->
  T = os:system_time(millisecond),
  (T div TimeWindow) rem NBuckets.
